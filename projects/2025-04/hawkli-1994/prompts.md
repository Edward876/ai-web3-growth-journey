# MnemoVault AI 提示词记录

## 项目开发过程中的关键 AI 交互

### 初始需求提示词

```
我们现在需要实现一个助记词分片加密的cli软件，使用golang实现，代码位置放到 projects/2025-04/hawkli-1994文件夹下面。主要原理为输入助记词后，再次要求输入密码，然后直接使用aes256最高强度的算法加密，加密完成后，把密文拆成三分，打印出来。
```

**AI 理解和执行要点**:
- 识别了需要实现CLI工具的需求
- 明确了使用Golang语言
- 理解了AES-256加密要求
- 掌握了分片输出的核心功能

### 技术实现相关提示词

#### 1. 加密算法选择

**提示词**: "使用aes256最高强度的算法加密"

**AI 建议**:
- 选择AES-256-GCM模式而非CBC模式
- GCM提供认证加密(AEAD)功能
- 包含完整性校验和认证
- 抵抗多种密码学攻击

#### 2. 安全性增强

**AI 主动建议**:
```
- 使用随机盐值(Salt)增强安全性
- 每次加密生成不同的Nonce
- 实现密码二次确认机制
- 添加助记词格式验证
```

#### 3. 分片算法设计

**AI 实现方案**:
```go
// 计算每个分片的长度
totalLen := len(ciphertext)
shardLen := totalLen / 3
remainder := totalLen % 3

// 均匀分配剩余字符
for i := 0; i < 3; i++ {
    end := start + shardLen
    if i < remainder {
        end++
    }
    // 创建分片
}
```

### 用户体验优化提示词

#### 1. CLI界面美化

**AI 建议的改进**:
```
- 添加 Unicode 表情符号增强视觉效果
- 使用分隔线美化输出格式
- 提供详细的操作状态反馈
- 实现友好的错误提示信息
```

#### 2. 安全提示信息

**AI 生成的安全建议**:
```
• 将每个分片保存在不同的安全位置
• 不要将所有分片存储在同一设备上  
• 确保密码的安全性，丢失密码将无法恢复
• 建议将分片保存在离线环境中
```

### 代码优化相关交互

#### 1. 依赖管理优化

**问题**: 初始版本使用了 `golang.org/x/term` 外部依赖

**AI 解决方案**:
```
简化设计，使用标准库 bufio.Reader 替代
移除外部依赖，提高程序的可移植性
修改 go.mod 文件，仅保留必要配置
```

#### 2. 错误处理完善

**AI 建议的错误处理**:
```go
// 助记词验证
if err := validateMnemonic(mnemonic); err != nil {
    fmt.Printf("❌ 助记词格式错误: %v\n", err)
    os.Exit(1)
}

// 密码长度检查
if len(password) < 8 {
    fmt.Println("❌ 密码长度至少需要8位字符")
    os.Exit(1)
}

// 密码确认检查
if password != confirmPassword {
    fmt.Println("❌ 两次输入的密码不一致")
    os.Exit(1)
}
```

### 文档生成相关提示词

#### 1. README.md 生成

**指导原则**:
```
- 包含项目介绍、技术实现和使用方法
- 详细说明加密算法和安全特性
- 提供完整的编译和运行指南
- 添加安全建议和使用注意事项
```

#### 2. 演示文档创建

**AI 建议的演示内容**:
```
- 完整的命令行交互流程
- 不同测试用例的演示
- 编译和运行的详细步骤
- 安全特性的可视化展示
```

### 安全性评估提示词

#### 1. 密码学安全分析

**AI 安全评估**:
```
✅ AES-256-GCM 提供强加密保护
✅ 随机盐值防止彩虹表攻击  
✅ 认证加密确保数据完整性
✅ 分片机制分散安全风险
```

#### 2. 实现安全建议

**AI 建议的改进点**:
```
- 考虑添加密钥派生函数(PBKDF2)
- 实现内存清理防止数据残留
- 添加输入数据的格式验证
- 考虑实现分片重组功能
```

### 项目结构规划

**AI 建议的文件结构**:
```
projects/2025-04/hawkli-1994/
├── main.go          # 主程序文件
├── go.mod           # Go模块配置  
├── README.md        # 项目说明文档
├── demo.md          # 演示文档
└── prompts.md       # AI交互记录
```

## AI 辅助开发的价值总结

### 1. 技术指导
- 🔐 密码学最佳实践建议
- 🛡️ 安全漏洞识别和修复
- ⚡ 性能优化建议
- 🔄 代码重构指导

### 2. 用户体验
- 💻 CLI界面设计优化
- 📝 友好的错误提示信息
- 🎨 视觉效果增强
- 📋 完整的使用指南

### 3. 文档完善
- 📚 详细的技术文档
- 🎯 清晰的使用说明
- 🔍 安全使用指南
- 💡 最佳实践建议

### 4. 代码质量
- 🏗️ 清晰的项目结构
- 🔧 健壮的错误处理
- 📏 一致的编码风格
- ✅ 完整的功能实现

### 恢复功能开发迭代

#### 用户新需求提示词
```
我们还需要增加一个恢复方法，输入三个加密分片和密码后，可以恢复助记词。
```

**AI 实现方案**:
- 添加主菜单模式选择功能
- 实现AES-256-GCM解密函数
- 创建分片重组算法
- 添加完整的错误处理机制

#### 关键技术实现

**1. 分片重组算法**:
```go
func combineShards(shards []string) (string, error) {
    if len(shards) != 3 {
        return "", fmt.Errorf("需要恰好3个分片，当前有%d个", len(shards))
    }
    
    // 直接连接分片
    combined := strings.Join(shards, "")
    
    // 验证组合后的字符串是否为有效的base64
    _, err := base64.StdEncoding.DecodeString(combined)
    if err != nil {
        return "", fmt.Errorf("分片组合后不是有效的base64格式: %v", err)
    }
    
    return combined, nil
}
```

**2. AES-256-GCM解密实现**:
```go
func decryptAES256GCM(ciphertext, password string) (string, error) {
    // Base64解码 → 提取盐值 → 生成密钥 → GCM解密
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    // ... 完整的解密流程
    plaintext, err := gcm.Open(nil, nonce, cipherData, nil)
    return string(plaintext), nil
}
```

**3. 用户界面优化**:
- 添加主菜单选择系统
- 分离加密和恢复流程
- 提供详细的操作反馈
- 增强错误处理和用户提示

#### 安全性考虑

**AI 建议的安全增强**:
```
- 验证分片完整性和格式
- 确保解密过程的异常处理
- 添加恢复后的助记词格式验证
- 提供安全使用建议和警告
```

## 开发感悟

通过与 AI 助手的协作开发，我们实现了一个功能完整、安全可靠的助记词分片加密工具。特别是在添加恢复功能的迭代中，AI 展现了出色的：

### 技术能力
- 🔄 **逆向思维**: 从加密流程逆推解密实现
- 🔍 **细节把控**: 处理Base64编码、盐值提取等技术细节
- ⚡ **快速迭代**: 在现有代码基础上快速添加新功能

### 用户体验设计
- 🎯 **交互优化**: 设计直观的主菜单选择系统
- 📝 **文档同步**: 及时更新文档反映新功能
- 🛡️ **安全提醒**: 提供恢复后的安全使用建议

这次开发体验展示了 AI 辅助编程在 Web3 安全工具开发中的巨大价值，特别是在涉及密码学和安全性要求较高的场景中。AI 不仅能实现复杂的技术功能，还能从用户体验和安全最佳实践的角度提供全方位的开发支持。
